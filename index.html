<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Rubik's Cube Slice Rotation - Single Cubelet Version</title>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
   

    <link rel="stylesheet" href="css/style.css">
    
  </head>
  <body>
  <div id="rubiks-menu">
  <h3>Rubik's Cube Slice Control</h3>
   <div class="head">
    Front Horizontal
  </div>
    <div class="slice-control">
    <span>Top Layer (Y-axis, y=2):</span>
    <button onclick="rotateSlice('UL')">&larr;</button>
    <button onclick="rotateSlice('U')">&rarr;</button>
  </div>
  
  <div class="slice-control">
    <span>Middle Layer (Y-axis, y=2):</span>
    <button onclick="rotateSlice('MYL')">&larr;</button>
    <button onclick="rotateSlice('MY')">&rarr;</button>
  </div>

  <div class="slice-control">
    <span>Bottom Layer (D, y=1):</span>
    <button onclick="rotateSlice('DL')">&larr;</button>
    <button onclick="rotateSlice('D')">&rarr;</button>
  </div>
 <div class="head">Front Vertical</div>

<div class="vertical-row">
  <div class="arrow-pair">
    <button onclick="rotateSlice('LL')">&uarr;</button>
    <button onclick="rotateSlice('L')">&darr;</button>
  </div>

  <div class="arrow-pair">
    <button onclick="rotateSlice('MXL')">&uarr;</button>
    <button onclick="rotateSlice('MX')">&darr;</button>
  </div>

  <div class="arrow-pair">
    <button onclick="rotateSlice('RL')">&uarr;</button>
    <button onclick="rotateSlice('R')">&darr;</button>
  </div>
</div>
  <div class="head">
    Sides
  </div>
  <div class="slice-control">
    <span>Front Layer (F, z=-2):</span>
    <button onclick="rotateSlice('FL')">&larr;</button>
    <button onclick="rotateSlice('F')">&rarr;</button>
  </div>

  <div class="slice-control">
    <span>Middle Layer (Z-axis, z=-3):</span>
    <button onclick="rotateSlice('MZL')">&larr;</button>
    <button onclick="rotateSlice('MZ')">&rarr;</button>
  </div>

  <div class="slice-control">
    <span>Back Layer (B, z=-4):</span>
    <button onclick="rotateSlice('BL')">&larr;</button>
    <button onclick="rotateSlice('B')">&rarr;</button>
  </div>

  <div class="slice-control">
    <button onclick="random()">&#8623 Randomize Cube</button>
  </div>
</div>

    <a-scene>
      <a-assets>
        <a-asset-item id="cube-model" src="./assets/rcube.glb"></a-asset-item>
        <img id="skyTexture" src="./assets/2011-09-21_15-46-44-salbert.jpeg" crossorigin="anonymous"/>
        <a-asset-item id="building" src="./assets/Glorious Amur-Trug.glb" ></a-asset-item>
        <a-asset-item id="uc" src="./assets/Smashing Sango.glb" ></a-asset-item>
        <a-asset-item id="solve_the_cube" src="./assets/solve_the_cube.glb" ></a-asset-item>
      </a-assets>
      <a-sky src="#skyTexture"></a-sky>
      <a-entity light="type: directional; intensity:2.5; color:#fff" position="1 4 2"></a-entity>
       <a-entity light="type: directional; intensity:2.5; color:#fff" position="1 4 -2"></a-entity>
      <a-entity light="type: directional; intensity:2.5; color:#fff" position="-1 4 -2"></a-entity>
      <a-entity light="type: ambient; intensity:3.6; color:#fff"></a-entity>
      <a-entity light="type: point; intensity:3.6; distance:10" position="-3 2 0"></a-entity>
      <a-entity light="type: point; intensity:3.6; distance:10" position="0 1 -5"></a-entity>
      <a-entity id="cube-cluster"></a-entity>
     
 
      <a-entity gltf-model="#building"  scale="200 200 200" position="0 -13 -10" color="#4562b5"></a-entity>
      <a-entity gltf-model="#uc" scale="100 100 100" position="4 10 -10" rotation="90 0 0"></a-entity>
      <a-box color="#abcdf1" position="-4 2 -5" rotation="45 45 45" animation="property: position; to: -4 3 -5; dur: 2000; easing: easeInOutQuad; loop: true; dir: alternate;"></a-box>
      <a-entity gltf-model="#solve_the_cube" scale="30 30 30" rotation="90 0 0" position="0 4.5 -5"></a-entity>
      <a-box color="#abcdf1" position="4 2 -5" rotation="45 45 45" animation="property: position; to: 4 3 -5; dur: 2000; easing: easeInOutQuad; loop: true; dir: alternate;"></a-box>
     
    </a-scene>
  
    <script>
    // Cube parameters
    let isRotating = false;
    const positions = [-1, 0, 1];
    const layersY = [1, 2, 3];
    const layersZ = [-4, -5, -6];
    const cubeSize = 0.97;
    const model = '#cube-model';

    faces=['U','UL','L','LL','R','RL','DL','D','B','BL','F','FL','MYL','MY','MZ','MZL','MXL','MX'];

    // Slices definitions, with their centers and match functions
    const sliceDefs = {
      U:  {center: [0,3,-5],  match: (x,y,z) => y===3, axis: 'y', angle: 90},      // Top row
      D:  {center: [0,1,-5],  match: (x,y,z) => y===1, axis: 'y', angle: 90},     // Bottom row
      MX:  {center: [0,2,-5],  match: (x,y,z) => x===0, axis: 'x', angle: 90},      // Top row
      MY:  {center: [0,2,-5],  match: (x,y,z) => y===2, axis: 'y', angle: 90},     // Bottom row
      MZ:  {center: [0,2,-5],  match: (x,y,z) => z===-5, axis: 'z', angle: 90},      // Top row
      L:  {center: [-1,2,-5], match: (x,y,z) => x===-1, axis: 'x', angle: 90},    // Left column
      R:  {center: [1,2,-5],  match: (x,y,z) => x===1, axis: 'x', angle: 90},      // Right column
      F:  {center: [0,2,-4],  match: (x,y,z) => z===-4, axis: 'z', angle: 90},     // Front slice
      B:  {center: [0,2,-6],  match: (x,y,z) => z===-6, axis: 'z', angle: 90},    // Back slice

      UL:  {center: [0,3,-5],  match: (x,y,z) => y===3, axis: 'y', angle: -90},      // Top row
      DL:  {center: [0,1,-5],  match: (x,y,z) => y===1, axis: 'y', angle: -90},     // Bottom row
      MXL:  {center: [0,2,-5],  match: (x,y,z) => x===0, axis: 'x', angle: -90},      // Top row
      MYL:  {center: [0,2,-5],  match: (x,y,z) => y===2, axis: 'y', angle: -90},     // Bottom row
      MZL:  {center: [0,2,-5],  match: (x,y,z) => z===-5, axis: 'z', angle: -90},      // Top row
      LL:  {center: [-1,2,-5], match: (x,y,z) => x===-1, axis: 'x', angle: -90},    // Left column
      RL:  {center: [1,2,-5],  match: (x,y,z) => x===1, axis: 'x', angle: -90},      // Right column
      FL:  {center: [0,2,-4],  match: (x,y,z) => z===-4, axis: 'z', angle: -90},     // Front slice
      BL:  {center: [0,2,-6],  match: (x,y,z) => z===-6, axis: 'z', angle: -90},    // Back slice
    };

    // Create all cubelets under cube-cluster, no duplicates
    const cluster = document.getElementById('cube-cluster');
    let cubelets = [];
    for (let y of layersY) {
      for (let x of positions) {
        for (let z of layersZ) {
          let cubelet = document.createElement('a-entity');
          cubelet.setAttribute('gltf-model', model);
          cubelet.setAttribute('position', `${x} ${y} ${z}`);
          cubelet.setAttribute('scale', `${cubeSize} ${cubeSize} ${cubeSize}`);
          cubelet.setAttribute('rotation', `0 0 0`);
          cubelet.classList.add('cubelet');
          cubelet.setAttribute('data-x', x);
          cubelet.setAttribute('data-y', y);
          cubelet.setAttribute('data-z', z);
          cluster.appendChild(cubelet);
          cubelets.push(cubelet);
        }
      }
    }

    // Utility: Convert string rotation to object
    function parseRotation(rot) {
      if (typeof rot === 'string') {
        let arr = rot.trim().split(/\s+/).map(Number);
        return {x: arr[0]||0, y: arr[1]||0, z: arr[2]||0};
      }
      return rot || {x:0, y:0, z:0};
    }
    
    function rotateSlice(face) {
      if(isRotating){return;}
      isRotating=true;
      const sliceDef = sliceDefs[face];
      if (!sliceDef) return;
      const {center, match, axis, angle} = sliceDef;
      
      // Find affected cubelets
      let affected = cubelets.filter(cubelet => {
        const x = parseInt(cubelet.getAttribute('data-x'));
        const y = parseInt(cubelet.getAttribute('data-y'));
        const z = parseInt(cubelet.getAttribute('data-z'));
        return match(x,y,z);
      });

      // For each affected cubelet, animate rotation about the slice center
      affected.forEach(cubelet => {
        // Get current position and rotation
        let pos = cubelet.getAttribute('position');
        let rot = parseRotation(cubelet.getAttribute('rotation'));

        // Compute position relative to slice center
        let rel = {
          x: pos.x - center[0],
          y: pos.y - center[1],
          z: pos.z - center[2]
        };

        // Rotate rel position around axis by angle
        let rad = angle * Math.PI/180;
        let newRel = {...rel};
        if (axis === 'x') {
          newRel.y = rel.y * Math.cos(rad) - rel.z * Math.sin(rad);
          newRel.z = rel.y * Math.sin(rad) + rel.z * Math.cos(rad);
        } else if (axis === 'y') {
          newRel.x = rel.x * Math.cos(rad) - rel.z * Math.sin(rad);
          newRel.z = rel.x * Math.sin(rad) + rel.z * Math.cos(rad);
        } else if (axis === 'z') {
          newRel.x = rel.x * Math.cos(rad) - rel.y * Math.sin(rad);
          newRel.y = rel.x * Math.sin(rad) + rel.y * Math.cos(rad);
        }

        // Compute new world position
        let newPos = {
          x: center[0] + Math.round(newRel.x),
          y: center[1] + Math.round(newRel.y),
          z: center[2] + Math.round(newRel.z)
        };

        // Animate position
        cubelet.setAttribute('animation__pos', {
          property: 'position',
          to: `${newPos.x} ${newPos.y} ${newPos.z}`,
          dur: 600,
          easing: 'easeInOutQuad'
        });

        // Animate rotation (just axis for visual)
        let newRot = {...rot};
        if (axis === 'x') {
          newRot.x += angle;
        } else if (axis === 'y') {
          newRot.y += angle;
        } else if (axis === 'z') {
          newRot.z += angle;
        }
        cubelet.setAttribute('animation__rot', {
          property: 'rotation',
          to: `${newRot.x} ${newRot.y} ${newRot.z}`,
          dur: 600,
          easing: 'easeInOutQuad'
        });

        // Update stored position/rotation after animation completes
        setTimeout(() => {
          cubelet.setAttribute('position', `${newPos.x} ${newPos.y} ${newPos.z}`);
          cubelet.setAttribute('rotation', `${newRot.x} ${newRot.y} ${newRot.z}`);
          cubelet.setAttribute('data-x', newPos.x);
          cubelet.setAttribute('data-y', newPos.y);
          cubelet.setAttribute('data-z', newPos.z);
          // Remove animation so further clicks work
          cubelet.removeAttribute('animation__pos');
          cubelet.removeAttribute('animation__rot');
          isRotating=false;
        }, 650);
      });
    }
    window.rotateSlice = rotateSlice;
    async function random(){
      let r=0;
      for(let i=0;i<10;i++){
        r=Math.floor(Math.random() * 18);
        console.log(r);
        console.log(faces[r]);
        rotateSlice(faces[r]);
       await sleep(650);
      }
    }
    function sleep(time) {
  return new Promise((resolve) => setTimeout(resolve, time));
}

    </script>
  </body>
</html>
